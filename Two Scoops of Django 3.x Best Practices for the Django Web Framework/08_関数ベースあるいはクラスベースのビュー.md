# Two Scoops of Django 3.x

## 8. 関数ベース、あるいはクラスベースのビュー
- **関数ベースのビュー**(FBV)と**クラスベースのビュー**(CBV)は、どちらもDjangoの中核をなすものである。
- 両タイプのビューの使い方を理解することを推奨する。

### 8.1 FBVとCBVをどう使うか
- ビューを実装するときは、FBVとCBVのどちらで実装するのが理にかなっているのか考えること。
- どちらの方法を選択すべきかわからない場合のために、以下にフローチャートを示す。

<br>
<img src=".\img\08_flowchart.png" width="80%">
<br>

- このフローチャートは、FBVよりもCBVを使用することを推奨している。
  - ほとんどのビューにはCBVを使用し、FBVはカスタムエラービューやCBVでは実装が困難な複雑なものだけを実装するために使用する。
- [TIP] 基本的にFBVを使用するアプローチ
  - ほとんどのビューにFBVを使用し、サブクラス化が必要なビューにのみCBVを使用するという方法を好む開発者もいる。

### 8.2 ビューのロジックをURLConfsに入れない
- リクエストは `URLConfs` を経由して、通常`urls.py`という名前のモジュール内のビューに送られる。
- URLルートの定義はシンプルでなければならないということを念頭に置くこと。
- viewsモジュールにはビューに関するロジックのみが含まれ、URLモジュールにはURLに関するロジックのみが含まれるべき。
- 以下、URLにビューロジックが含まれる悪い例。

```python
# Don't do this!
from django.urls import path
from django.views.generic import DetailView

from tastings.models import Tasting

urlpatterns = [
    path('<int:pk>',
        DetailView.as_view(
            model=Tasting,
            template_name='tastings/detail.html'),
        name='detail'),
    path('<int:pk>/results/',
        DetailView.as_view(
            model=Tasting,
            template_name='tastings/results.html'),
        name='results'),
]
```

- このコードは一見すると問題ないように見えるが、筆者は以下の理由でDjangoの設計理念に反していると考える。
  - ビュー、URL、モデルが密結合になっており、ビュー定義の再利用ができなくなっている。
  - CBV間で同じ (または類似した) 引数が繰り返し使われており、DRY原則に違反している。
  - URLの柔軟性が破壊されている。CBVの最大の利点であるクラスの継承は、このアンチパターンでは不可能になっている。
  - 他にもたくさんの問題がある。
    - 認証を追加しなければならない場合どうするか？
    - 承認については？それぞれのURLConfビューを2つ以上のデコレータでラップすることになる？
    - 訳者註: 認証 (Authentication)は「サービスへアクセスしてきたユーザが本人かどうか検証すること」、承認 (Authorization) は「認証済みユーザーが指定したリソースへアクセスできるかどうかを制御すること」。

- 次のセクションでは、良い例を紹介する。

### 8.3 URLConfsを疎結合にする
- ここでは、先述した問題を回避するURLConfsの実装方法を紹介する。
- まず、viewsを作成する。

```python
from django.urls import reverse
from django.views.generic import ListView, DetailView, UpdateView

from .models import Tasting

class TasteListView(ListView):
    model = Tasting

class TasteDetailView(DetailView):
    model = Tasting

class TasteResultsView(TasteDetailView):
    template_name = 'tastings/results.html'

class TasteUpdateView(UpdateView):
    model = Tasting

    def get_success_url(self):
        return reverse('tastings:detail',
            kwargs={'pk': self.object.pk})
```

- 次にURLを定義する。

```python
from django.urls import path

from . import views

urlpatterns = [
    path(
        route='',
        view=views.TasteListView.as_view(),
        name='list'
    ),
    path(
        route='<int:pk>/',
        view=views.TasteDetailView.as_view(),
        name='detail'
    ),
    path(
        route='<int:pk>/results/',
        view=views.TasteResultsView.as_view(),
        name='results'
    ),
    path(
        route='<int:pk>/update/',
        view=views.TasteUpdateView.as_view(),
        name='update'
    )
]
```

- この方法を採用する理由は、以下のとおり。
  - **DRY原則**
    - 引数や属性がビュー間で繰り返されることはありません。
  - **疎結合**
    - ビューはビューで、URLConfsはURLConfsであるべきなので、URLConfからモデルとテンプレートの名前を削除している。
    - 複数のURLConfsからビューを呼び出すことが可能になる。
  - **一つのことをうまくやる**
    - URLConfはURLルーティングという単一の責任にフォーカスしている。
    - ビューのロジックを追跡する時に、ビューを読むだけで済む。(ビューとURLConfsの両方を読む必要がない)
  - **CBVであることの恩恵**
    - ビューモジュールとして正式に定義されているので、他のクラスを継承することができる。
    - つまり、認証や承認などのビジネス要件に対応しやすい。
  - **無限の柔軟性**
    - ビューモジュールとして正式に定義されているので、独自のカスタムロジックを実装することができる。











